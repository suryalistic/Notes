Android platform:
	Architecture from Top to Bottom:
	Applications -> Application Framework -> libraries and Run Time -> linux kernel
	Linux Kernel: 
				security
				memory and process management
				file and net I/O
				device drivers
				power management services
				shared memory
				interprocess management
	Libraries:
				written in c
				provides:
				System C Library
				Surface manager(display)
				media framework
				webkit
				openGl
				SQLite
	Android Runtime:
				Core Java Libraries (java, javax, android.*, junit)
				Dalvik VM
				App written in Java -> java compiler compiles to Java byte code ->  DX tool converts byte code to a single DEX Byte Code (class.DEX) -> Dalvik VM runs the dex file
				(More on Dalvik @ youtube.com -> Dalvik VM internals by DAN BORNSTEIN)
				
	Application Framework:
				package manager : keeps track of all apps on device
				window manager : manages windows of the applications
				view system: common gui like icons etc
				resource manager : manages non compiled resources like strings etc (for ex: customization for I18n, think properties on java system)
				activity manager: manages life cycle of app.
				content providers: dbs for store and share data usually cross applications
				location managers: allows apps to location and movememnt information
				notification manager: allows app to place notifications in the bar.
	Applications
				built in applications	(no app is harcoded into the system, any app can be replaced)
	
	Android Building Blocks: All are built in Java
		.Activity(provide Gui)
			For user interaction
			activity should focus on single thing.
		.Services
			run in bg, eg: music has many activities and one service while the user switches
			between screeens
			
		.BroadcastReceiver(for event handling on device)
			Listen  for and respond to events, subscriber in a publish subscriber pattern
			EVents = Intent class.
			BroadastReceiver listens for events and responds eg: sms software
			
		.Content Providers(Store and share data)
			db style interface but more than db
			handles communication between processes
			
		Apps are made of individual components which have its own purpose and API.
	
	Resources:
		Non-Source code in android are resources like Strings, layout, images, graphics etc.
		Resources are more like constants or properties. Can be changed without altering the source code.
	
		Strings can be of three types:
			stored in RES/VALUES/*.xml
			String, String array, Plurals
			are defined in an xml file : <String name="">value</String>
			can be accessed from other resources like @String/string-name
			can be accessed from Java like R.String.String-name
			can be defined for multile lanaguages (i18n)
		Layout files specify the ui layout 
			are stored in RES/LAYOUT/*.xml
			accessed in Java as R.Layout.layout_name
			in other resources are :@Layout/layoutname
			multiple layout based on location
		
		Resources can be accessed in Java using R.* , where R is a class in the android package
		R.java is generated by the application framework. should not be modified.
			
	**** important class to look at in android ***
	DialtactsActivity.java in DialtactsActivity package
	MediaPlaybackService.java in MusicbriwserActivity package
	SMSReceiver class for BroadcastReceiver example
	BrowserProviderClass in BrowserActivity package
	************************************************
	
	While packaging the application in to .apk file, a manifest file is to be written that: AndroidManifest.xml file.
	This hold information about modules, security , hardware that is required and used in the app. etc., minimum API level of android
	
	
	
	Activity Class:
		.Primary user interface , Activity should be modular i.e one activity should handle one thing only.
		.Multiple Activities string together for an Application.
		.User can jump thru multiple activities and android helps maintain state thru various elements : tasks, 
		  task BackStack (stack with activities on them), 
		 suspend and resume activity.
		.Task is a set of related activities. not necessarily from the same application.
		.TaskBackStack: Activity started -> pushed onto top backstack
						Activity Destroyed -> popped from the backstack
		.Activity Life cycle: Activities are created, suspended, resumed, destroyed.
		.Activity life cycle stages usually are : create , Running/Resumed , paused/suspended, Stopped/Destroyed.
		.Entire Activity Lifecycle: App starts -> onCreate(savedState) -> onstart() -> onResume() -> Activity Running ->onPause() -> onStop()->onDestroy().
			onPause() can continue to onResume(), onStop() can go to onStart() with a onRestart();
		.User Visible life cycle is from onStart to OnStop
		.User Visible and in foreground where user can interact with the app is from onResume to onPause.
	
	LifeCycle Methods:
		.OnCreate:
			Called when application is created.sets up initial state, calls super.oncreate, sets contentview with layout file, 
		.OnRestart:
			called when application is stopped and needs to be started again.
			can be used to handle special actions to be performed when activity is about to started after stopped.
		.OnStart:
			called when application is about to become visible.
			typically used: request location , reading unread msgs etc
		.onResume: 
			called when application is about to come to foreground. user ready to interact
			use to do start animations , music etc.
		.onPause: 
			called when application is about to go to foreground.user stop interaction.
			can be used to stop foreground behaviors like stop animation etc., also can save persisted state.
		.onStop:
			activity no longer visible to user, may be restarted,
			can be used to cache activity state. this may not be called if application is shutdown by android for want of resources. so better 
			handle the saving persistent state in onPause.
		.onDestroy:
			when activity is completely removed, application is stopped. 
			can be used to release resources. this also may not be called by android when shutdown for resources
			
		Configuration changes like orientation of phone, keyboard etc will kill the current activity and restarts it(onDestroy followed by onCreate). So activity methods need to be fast.
		To speed up startup methods two sols:
			. to create a Java Object override onRetainNonConfigurationInstance (called sometime bet'n onStart and onStop)  
				and build the object and retrieve it. This object can be retrieved in onCreate using getLastnonConfigurationInstance()
			. manual reconfiguration: mention configuration changes that you want to handle manually in the manifest.xml file. So when the system
				hits these changes like orientation changed etc. it will call the onConfigurationChanged() method of activity to handle it manually.
		Call one Activity from another by instantiating an Intent and calling android framework's startActivity or startActivityForResult methods.		
				
Intent Class:
	Intent class can be used to explicitly call an Activation class by specifying the name of the Activity or implicitly by specifying an action anfter which the android framework picks the activity to be started.
	Intent is a data structure that represents an operation to be performed or and event that has occurred. Intents with events need a listener and thus only used with broadcase receivers.
	Intents can be created by activity when they want a work to be performed by another activity. Android then calls the other activity. This intent is received by the other activity and work is performed.
	As intent is a data-structure, here are the fields that it holds:
		action: Explicitly specify and action to be taken. eg: Action_Dial, Action_Dial, action_main (to specify initial activity of application). Specified as 
		new Intent(Action_XXX) or Intent.setAction(Action_XXX)
		
		data: data associated with an intent. formatted as URI
			eg: URI.parse("tel:15534343"). tel: here is called scheme
			Intent(URI.Parse())		
		category: additional info abt the components that should handle this intent. for eg: browsable category etc. Category_BROWSAbLe
		Type: mime-type eg: image/png, text/plain . Intent.setType()
		component: targets which activity should receive this intent. should be specified with context and activity class name. eg: new Intent(Context.xxx, class)
		intent.setComponent, setCLass
		extras: extra data as Map(key value) eg: intent.putExtra(XXXX, XXXX)
		flags: how intent should be handled. for eg: dont store history etc.
		
		target Activity
			Activity can be explicitly mentioned in an intent which is a direct way to call and activity.
			Activity can be implicitly be resolved by android by the formation of the intent class. Intent Resolution. 
			Intent Resolution in implicit situation: Requires two pieces of data: the intent should describe the desired operation. IntentFilters in AndroidManifest.xml or programatically menioned.
			Intent Resolution looks at action in the intent, data (URI and mime-type) and category.
			IntentFilter mentioned is in the manifest -> activity -> intent filter -> action section where action name is specified.
			manifest -> activity -> intent filter -> data where URI, mime type is specified (URI = host, port etc)
			manifest -> activity -> intent filter ->category
			
			***Look at Google maps applications android manifest xml.
			Activities that want to receive implicit intent must declare category.DEFAULT in their IntentFilter settings.
			Priority is used to determine between activities that can handle the implicit intent.
			
			(Look at HelloWAndroidWithLgin from source code)
			
	
	Permissions:
	
			Android uses permisssions to control access to Resources, Data and Operations. 
			Persmissions are represented as Strings and are maintained in Manifest.xml file. Permssions they use themselves or want other components to use of them. mainfest -> uses-permission section of manifest. (remember the permissions you accept when installing an app or using it the first time?? comes from here)
			developer.android.com/reference/android/Manifest.permission.html
			(look at MapApplicationWithComtacts)
			Android lets applications to define and enforce our own permissions to limit access of other application accessing our application. defined in  manifest file at manifest -> Permission
			(look at the PermissionexampleBoom and PermissionexampleBoomUser )
		Similar to application permissions as shown above, individual components(Activities etc.) can also set their own permissions. these perms have priority over application level perms. 
		ActivityPermissions restrict which other components can start this activity. checked in startActivity and startActivityForResult and throws securityException.
		ServicePermissions restrict which components can bind or start the service.checked when components try to start stop or bind to service. eg: COntext.StartService. and throws securityException.
		BroadCastReceiver Permissions restrict which components can send and receive broadcasts. checked in multiple places.
		ContentProvider permissions checked which components can read or write data.
		
	
	
	Fragment Class:
		were added in android 3.0 to support tablets
		(Eg: QuoteViewer application, fragmentstaticlayout )
		 Fragment is a part of Activity's UI.
		 fragments are hosted by activities
		 one activity can contain 0...* fragments 
		 one fragment can be hosted on 0...* activities 
		 Fragment is hosted on activity hence its life cycle is tied to that of activity. fragment has its own life cycle event call backs.
		 fragment lifecycle:
		 	REsumed(Running): is visible in running activity
		 	Paused : another activity is in forground and has focus. containing activity is visible.
		 	Stopped: Fragment is not visible.
		 	
		 	call back methods:
		 		when fragment's hosted activity is created, fragment is created and attached.
		 		Activity OnCreate() -> Fragment onAttach() -> Fragment onCreate() -> Fragment onCreateView() ->(fragments sets up its UI and returns it to the activity ) -> fragment onActivityCreated
		 		
		 		Activity onStart() (activity about to become visible ) -> fragment onStart()
		 		Activity onResume() (activity about to get visible and focus) -> fragment onResume()
		 		Activity onPause()  (Activity about to lose focus) -> fragment onPause()
		 		Activity onStop() (Activity in background, lost focus) -> fragment onStop()
		 		Activity onDestroy (Activity about to shutdown) -> fragment onDestroyView() (destroys view created in onCreateView(), clean up resources related with view) -> fragment onDestroy() (when frag is no longer is use) -> fragment onDetach() (no longer used by hosting activity, can be used to nullify the ref to hosting activity.)
		 		
			Two ways to add fragment to activity:
				1.declare statically in activity layout file.
				
					.fragment layout ui can be filled in or created in onCreteView() of frag. which is then passed onto hosting activity which then adds it to its layout (in onCreate() method) (look at FragmentStaticLayout projec) 
					.fragments declared in the activity layout.xml file.
				2.use fragmentmaneger to programmatically add to activity.
					add fragment while activity is running, 
					.get reference to fragmentmaneger
					.begin fragmentTransaction
					.add a fragment
					.commit fragmentTransaction(look at fragmentprgrammaticlayout project)
					dynamic layout:
						can change ui layout when adding fragments programmatically.(look at fragmentDynamic Layout)
					****.when config changes such as layout changed , keyboard on etc are handle programmatically, if we call setRetainInstance(true) on fragment, that frag is not destroyed on activity changes(unlike activity where activity is destroyed when config is changed). Android will not call the onDestroy of fragment if that method is set on frag when the activity is destroyed. Since the fragment is not Destroyed ,when the hosting activity of that frag is created again, the frag is not created again but the older frag is re-used. So no calls to onDestroy or onCreate of fragment if that method is set to true on fragment.(look at FragmentStaticConfigLayout)****
		
		
User Interface:
	.View is basic building block
		occupy rectangular space, draw themselves and respond to events
		eg of view: button, checkbox etc.
		 Views are organized as trees.
		 outermost view -> view -> view ....
		 when android displays the ui (draws ui), it traverses the tree mulitple times.
		 first pass -> measures all views -> view's onMeasure() is called by android
		 second pass -> positions -> view's onLayout()
		 third -> draws	-> onDraw()
		 if making cusomt view handle these methods
		 	onFocusChanged(), onKeyUp(), onKeyDown(), onWindowVisibilityChanged()
	.viewgroup eg: radioGroup, mapview, datepicker, timepicker, webview etc
	AdapterView are view groups used to display list of data.
	Layout view holds other views.
	LinearLayout: fixed layout where child layouts are arranged with fixed positions
	RelativeLayout: child layouts are arranged relative to each other and their parent
	TableLayout: rows and columns layout of child views 
	
	Menu:
		Options menu: kind of global menu. a virtual menu key
		Contextmenu : based on view. like clicj and hold a picture
		submenu: menu appears inside a view or layout from activity.
		
	
					
									
		 		
		  
		 
		 
		 
		 
		 
		 
			
			 
		
	
			
			 
				
	
	
	
	